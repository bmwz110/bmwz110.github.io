<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Angular生命周期详解]]></title>
    <url>%2F2019%2F08%2F20%2F20190820%2F</url>
    <content type="text"><![CDATA[Angular每个组件都存在一个生命周期，从创建，变更到销毁。Angular提供一种生命周期钩子，把这些关键时刻暴露出来，赋予在这些关键结点和组件进行交互的能力，便于我们更好地开发。 ngOnchanges()Purpose: Respond when Angular (re)sets data-bound input properties. The method receives a SimpleChanges object of current and previous property values. Timing: data-bound input properties change, like @Input() ngOnchanges()把发生变化的属性名映射到一个SimpleChange对象，这个对象中保存有映射属性的currentValue和previousValue，ngOnchanges()会根据属性变化对这两个value进行迭代更新。 Example: 123// child.component.ts@Input() name: string;@Input() addr: Address; // Address是一个对象 123&lt;!--parent.component.ts--&gt;&lt;input [name]="name"&gt;&lt;/input&gt;&lt;input [addr]="addr"&gt;&lt;/input&gt; 当输入的name变化时，就会触发ngOnchanges()，而当输入的addr变化时，不会触发。 ⚠️只有在改变值类型的input属性时执行，如果改变的是引用类型，则只有当引用地址变化时才会执行。 ngOnInit()Purpose: Initialize the directive/component Timing: after the first ngOnChanges(), only called once ngOnInit()用于在构造函数之后马上执行复杂的初始化逻辑，例如获取、绑定数据。 一般情况下，与服务器建立连接、获取数据的任务不应放在组件的constructor中，因为我们并不确定当前是否会用到该组件，constructor会浪费不必要的资源。在ngOnInit()中获取数据是合适的。 ngDoCheck()Purpose: Detect change, generally asynchronous situation Timing: after ngOnChanges() and ngOnInit() during every change detection ngDoCheck()用于监控变更，当Angular中的某个组件发生异步事件时，该组件中的ngDoCheck()就会检查整个组件树，以保证组件属性的变化是同步的。 ⚠️在每次变更检测周期之后，发生了变化的地方都会调用ngDoCheck()，因此此钩子的触发十分频繁。 ngAfterContentInit()Purpose: Indicates that the content has been projected Timing: after the first ngDoCheck(), only called once 12345678910&lt;!--parent component--&gt;&lt;child&gt; &lt;p&gt;父组件向子组件的投影内容&lt;/p&gt;&lt;/child&gt;&lt;!--child component--&gt;&lt;div&gt; &lt;!--接受父组件的投影内容--&gt; &lt;ng-content&gt;&lt;/ng-content&gt;&lt;/div&gt; 当组件模版中使用标签时，即表明存在content project。当子组件初始化完投影内容后，便会触发ngAfterContentInit(). ngAfterContentChecked()Purpose: checks the content projected into the directive/component. Timing: after the ngAfterContentInit() and every ngDoCheck() 与ngDoCHeck()类似，用于检测变更。 当父子组件同都满足触发条件时，会优先执行父组件的此钩子。 ⚠️由于ngDoCheck()也会触发此钩子，所以此钩子的触发也十分频繁。 ngAfterViewInit()Purpose: Indicates that the component and all the related child-components are rendered Timing: after the first ngAfterContentChecked(), only called once. 当组件本身及其所有相关子组件渲染完成，呈现在页面上后，触发此钩子。 ngAfterViewChecked()Purpose: Indicates that the change check has been completed Timing: after the ngAfterViewInit() and every ngAfterContentChecked() ⚠️由于ngAfterContentChecked()也会触发此钩子，所以此钩子的触发也十分频繁。 ngOnDestroy()Purpose: Cleanup just before Angular destroys the directive/component. Unsubscribe Observables and detach event handlers to avoid memory leaks. Timing: before Angular destroys the directive/component]]></content>
      <categories>
        <category>Angular</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cookie、Session和Token]]></title>
    <url>%2F2019%2F08%2F13%2F20190813%2F</url>
    <content type="text"><![CDATA[最近项目代码看到了关于网络安全的部分，就顺便来初步总结一下cookie、session和token这三个在身份校验中应用的比较多的方法。 HTTP请求是无状态的，即连即用，各次独立。其优点是每次请求都不用背负额外的信息，较为快速。但在访问某些需要登陆的网站时，短期内第二次登陆如果还需要输入账号密码甚至验证码，无疑是一种低效的行为。因此，睿智的人们想到了一个办法：通过给已登陆用户发放临时通行证，从而授权其在短时间内重复访问，无需再次输入账号密码。 这个操作的实现就是今天要谈的cookie、session和token。 Cookie cookie是存储在客户端的纯文本信息，一般不超过4KB。 cookie分为会话cookie和持久cookie。会话cookie是一种临时cookie，用户退出浏览器，会话cookie即被删除了。而持久cookie则会储存在硬盘里，用户关闭浏览器或重启电脑，它依然存在。 一般的cookie校验操作步骤如下： 用户登陆网站，请求被发送给服务端； 服务端生成一个cookie，与其它内容一起返回给客户端； 客户端收到cookie后，保存在本地； 客户端再次访问时，将cookie通过http header发送给服务端； 服务端对cookie进行校验，校验通过则允许访问。 Session cookie本身保存在客户端，一来大小受限，二来安全性较差，易被拦截窃取。因此一般将cookie与session相结合使用。步骤如下： 用户登陆网站，请求被发送给服务端； 服务端生成一个session（包括用户角色、登陆时间等信息）保存在服务端； 同时生成一个session_id返回给客户端，写入用户的cookie； 客户端再次访问时，将session_id通过cookie的方式发送给服务端； 服务端根据收到的session_id搜索session校验身份，校验通过则允许访问。 上述组合使用的优点十分明显：用户信息保存在服务端，无需考虑大小限制，且更加安全。同时，客户端仅需保存和使用session_id，更为便捷。 ⚠️与此同时也存在着一些缺点： 即当有多个服务器做负载均衡时，用户请求第一次被发送到服务器A，所生成的session也保存在服务器A，当用户再次访问时，可能被派发到服务器B，而服务器B上没有session。需要通过在各个服务器上同步session来解决这一问题； 一般情况下，为了防范一些低级风险，浏览器会采用同源策略。而cookie和session默认情况下无法跨域，即使cookie存在与header中，浏览器也会忽视； 同源策略：协议、域名、端口三者有一不同即为不同源，不同源的请求视为跨域。 移动端一般不支持cookie； 易遭受CSRF攻击（见附录1）。 这些问题的存在对用户校验提出了更高的要求，token应运而生。 Token token的意思为”令牌”，token是一种无状态的认证方式，服务端不会保存身份认证相关信息。其操作步骤如下： 用户登录成功后，服务端返回加密信息（token）给客户端； 客户端将收到的token保存在本地（一般是localStorage）； 用户再次访问时，将token放入http header中发送给服务端； 服务端进行token解密、校验用户身份。 可以看出，使用token进行身份校验，服务端是通过cpu进行加密和解密，无需在服务端开辟存储空间进行存储，同时也不需要考虑负载均衡的同步问题。是一种目前十分流行的方法。 一般防止CSRF的稳妥方法就是用token、以及验证码，尤其是注册、支付操作。 HTTP Referer可以告诉服务端网页是从哪个页面链接过来的，也被用于判定操作是否异常。 附录1:CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 (上例原文链接： https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html) ⚠️CSRF攻击是借助受害者的cookie骗取服务端信任，但黑客本身并无法拿到cookie，同时，由于浏览器同源策略的限制，服务端返回的数据，黑客也拿不到。所以黑客进行CSRF攻击只能是直接对服务端数据进行操作（例如转账、销户等），并不能获取服务端的数据（例如获取用户账号密码、转账记录等）。鉴于此，我们的重点防御点应落在服务端的非查询行为上。]]></content>
      <categories>
        <category>WEB通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[闭包及其应用]]></title>
    <url>%2F2019%2F05%2F26%2F20190526%2F</url>
    <content type="text"><![CDATA[什么是闭包？“在函数内使用其它函数内的变量，是为闭包” 123456789【例1】function a() &#123; let num = 100; return function b() &#123; console.log(num) &#125;&#125;var c = a()c() // 100 在例 1 中，a 为外层函数，a中返回了一个内部函数 b ， 函数 b 中使用了 a 中的 num 变量。此时，函数 b 就形成了一个闭包。 闭包的用处是什么？在JavaScript中，作用域链使得子作用域能够读取到父作用域的变量【见例2】，而反过来，父作用域无法直接获取子作用域的变量【见例3】。 1234567891011121314【例2】let num = 100function a() &#123; console.log(num)&#125;a() // 100【例3】function a() &#123; let num = 100&#125;console.log(num) // error: not defined 当我们想在父作用域使用子作用域的值时该怎么办呢？ 答：那就在函数内部再定一个函数，将其作为返回值即可【例4】。 123456789【例4】function a() &#123; let num = 100 return function b() &#123; return num &#125;&#125;var x = a()console.log(x()) // 100 例 4 中，函数 b 作为函数 a 的内部函数，可以访问 a 中的变量 num，于是我们将函数 b 作为返回值，我们通过操作 b 来访问 a 的变量。 上述利用闭包的特性来实现外部对内部的访问，便是闭包最基本的应用。 闭包的应用场景1. 封装变量以控制权限一般来说，我们只想让外界使用我们暴露出去的方法，而方法涉及到的变量计算想要封装在函数内部，以避免被有意/无意地修改变量值，此时，便可利用闭包来进行变量封装以控制权限【例5】。 1234567891011121314151617【例5】// 判断输入的变量是否是第一次输入function isFirstVisit() &#123; let _list = [] return function (id) &#123; if (_list.indexOf(id) &gt;= 0) &#123; console.log("Exist!") &#125; else &#123; _list.push(id) console.log("Added~") &#125; &#125;&#125;let firstVisit = isFirstVisit()firstVisit(5) // Added~firstVisit(5) // Exist!firstVisit(10) // Added~ 将 isFirstVisit 的返回值赋给 firstVisit ，然后通过使用 firstVisit 进行判断，因为暴露给外界使用的是 firstVisit 函数，所以只能使用该函数定义的方法，而无法对 _list 进行任何修改，保证了数据的私密性。 2. 函数柯里化函数柯里化就是把一个函数接收多个参数进行处理，转变为接收单一参数，然后返回一个新函数接收下一个参数【见例6】。 1234567891011【例6】// 普通函数function sum(x, y) &#123; return x + y&#125;// 函数柯里化function curryingSum(x) &#123; return function(y) &#123; return x + y &#125;&#125; 这里函数柯里化后的内部函数所使用的 x，就是其父作用域的变量，此时的内部函数就是一个闭包。 函数柯里化应用之 参数复用 12345678910111213141516171819202122【例7】 function check(reg, txt) &#123; return reg.test(txt)&#125;// 检验是否含有数字check(/\d+/g, 'test') // falsecheck(/\d+/g, 'abc') // falsecheck(/\d+/g, '2dd') // true// 柯里化后function curryingCheck(reg) &#123; return function(txt) &#123; return reg.test(txt) &#125;&#125;let hasNumber = curryingCheck(/\d+/g)hasNumber('test') // falsehasNumber('abc') // falsehasNumber('2dd') // true 通过上例可以看到，直接使用check函数，第一个参数“正则判断语句”在每次使用时都需要输入，既不美观也不方便。对其进行函数柯里化后，只需输入一次正则判断语句，便可对判断函数进行复用。 闭包带来的问题内存占用由于闭包使用其它函数内的变量，所以垃圾回收机制不会对闭包相关的函数进行回收，占用内存空间。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浅拷贝和深拷贝]]></title>
    <url>%2F2019%2F04%2F13%2F20190413%2F</url>
    <content type="text"><![CDATA[什么是深拷贝和浅拷贝呢？ 名称 定义 浅拷贝 对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝 深拷贝 对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容 也就是说，对于a，让b对a进行拷贝，之后当a发生变化，若b也跟着发生变化，就是浅拷贝；若a发生变化，b不变化，那就是深拷贝。 基本数据类型 引用数据类型 Number、String、Boolean、Null、Undefined等 Object、Array、Function等 基本数据类型是按值访问的，对其的拷贝会直接复制其值保存在新变量中。例如Number类型： 12345var a = 1;b = a;console.log(b); // 1a = 2;console.log(b); //1 （a的变化不会影响b的值） 而“引用数据类型”是按引用访问的，对其直接进行拷贝只会操作引用地址，而不是值本身。例如Array类型： 1234567var a = [1, 2, 3];b = a;console.log(a); // [1, 2, 3]console.log(b); // [1, 2, 3]a[0] = 2;console.log(a); // [2, 2, 3]console.log(b); // [2, 2, 3] （对数组a的改动也影响了数组b） 其原理如下图所示： 那么，如何对引用数据类型实现深拷贝呢？ 显而易见的思路是：既然是因为引用地址造成了无法深拷贝，那就抛开引用地址，直接对值进行遍历，将其拷贝给新的变量。 方法1: 手工遍历法12345678910111213141516let a = [1, [2, 3], 4];const copy = (obj) =&gt; &#123; let newObj = obj.constructor === Array ? [] : &#123;&#125; if(typeof obj !== 'object') &#123; return; &#125; for(let i in obj) &#123; newObj[i] = typeof obj[i] === 'object' ? copy(obj[i]) : obj[i] &#125; return newObj&#125;let b = copy(a); a[1][0] = 3;console.log(a); // [1, [3, 3], 4]console.log(b); // [1, [2, 3], 4] 方法2: JSON方法123456789101112let a = [1, [2, 3], 4];const copy = (obj) =&gt; &#123; let _obj = JSON.stringify(obj) let newObj = JSON.parse(_obj) return newObj&#125;let b = copy(a); a[1][0] = 3;console.log(a); // [1, [3, 3], 4]console.log(b); // [1, [2, 3], 4] 方法3: JQuery-extend方法1234567let a = [1, [2, 3], 4];b = $.extend(true,[],a);a[1][0] = 3;console.log(a); // [1, [3, 3], 4]console.log(b); // [1, [2, 3], 4]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6知识点整理]]></title>
    <url>%2F2019%2F03%2F17%2F20190317%2F</url>
    <content type="text"><![CDATA[1. let关键字let关键字是ES6添加的新关键字，作用是声明变量，主要为了弥补var关键字声明变量的缺点。 var关键字声明变量的缺点： 1. 作用域互相干扰1234567var arr = [];for(var i=0; i&lt;10; i++) &#123; arr[i] = function() &#123; alert(i) &#125;&#125;arr[5](); //结果10 块级作用域：一对花括号{}就是一个块，for循环的每一次循环都会创建一个块。 可以看出，var声明的变量i的值会干扰到各个块级作用域里的i，最后一个i的值为10，于是其他块级作用域中的i也都变成了10。 将var替换为let来声明变量就可以规避这种干扰： 1234...for(let i=0; i&lt;10; i++)...arr[5](); //结果5 2. “变量提升”现象观察下面这段代码： 1234567var a = 1;x = function() &#123; alert(a); var a = 2;&#125;;x(); //undefinedconsole.log(a); //1 预期的输出结果应该是：先弹出alert窗口显示1，然后a的值在函数体内的局部作用域被赋为2。但现实情况是alert窗口显示undefined。 这是因为上述函数内声明并定义变量a的语句”var a = 2”实际被拆分为两部分”var a”和”a = 2”，且第一部分”var a”被提前到函数体最前端（如下）： 1234567var a = 1;x = function() &#123; var a; alert(a); a = 2;&#125;;x(); 对于alert(a)来说，局部变量a并未定义，从而导致alert(a)出现undefined，这就是变量提升现象。 同样，使用let可以消除这种影响： 1234567var a = 1;x = function() &#123; alert(a); let a = 2;&#125;;x(); //a is not definedconsole.log(a); //1 这是因为，块级作用域内let声明变量a是封闭自给的，外界的变量a无法作用于内部。此时，要求“先声明后使用”，需要将”let a = 2”写在”alert(a)”之前。 1234567var a = 1;x = function() &#123; let a = 2; alert(a); &#125;;x(); //"弹窗提示"：2console.log(a); //1 需要注意的是：同一个块级作用域内，使用let声明变量时，同一个变量只允许声明1次。以下做法是错误的： 1234567891011121314&#123; var a = 1; let a = 2;&#125; //a has already been declared&#123; let a = 1; var a = 2;&#125; //a has already been declared&#123; let a = 1; let a = 2;&#125; //a has already been declared 还有需要注意的是：函数内不能使用let重新声明函数的参数。以下做法是错误的： 1234567var a = 1;x = function(a) &#123; let a = 2; alert(a); &#125;x(); //a has already been declared 这是因为函数通过参数引入了”var a = 1”，相当于在函数体内存在了这一声明，再使用let对a进行声明便犯了重复声明的错误， 总结： let关键字：1.只在块级作用域起作用；2.不可重复声明同一变量；3.不可声明函数参数； 2. const关键字const是constant(常量)的缩写，专用于声明常量。 ++let关键字有的特性，const全都有，并且const还多了2个特性++： 特性1: 不可修改 12const a = 1;a = 2; //error 特性2: 声明后必须赋值 12const a; a = 10; //error 对于特性1，有一点需要注意，当常量是值时，传值赋值的值是不可修改的。即当常量是一个对象时，使用的是传址赋值，不可修改的是“址”，而不是“值”。 例如： 1234const a = &#123;"number":1&#125;;a.number = 2;a.name = "math";console.log(a); //&#123;number:2, name:math&#125; 即对于传址赋值的情况，在值的层面是可以修改的。 3. SymbolSymbol是ES6中新增的数据类型，与之前的Number, String, Boolean, Null, Undefined, Object一起，成为7大数据类型。 作用：主要是为了防止属性名冲突造成的覆盖。例如当你调用他人的对象时，添加了一个名为a的方法，可能会覆盖掉他人对象中原本的a。 12345678910111213141516171819202122\&lt;script&gt; let obj = &#123; a: "hello", b: "world" &#125; let a = Symbol(); let b = Symbol("标记"); //Symbol中的字符串是为了区分不同的Symbol obj[a] = "one"; obj[b] = "two"; console.log(obj); // a: "hello" // b: "world" // Symbol(): "one" // Symbol(标记): "two" console.log(obj.a); //hello console.log(obj[a]); //one for(let item in obj) &#123; console.log(item) &#125; // a b\&lt;/script&gt; 其他关于Symbol的具体特性，可参见http://es6.ruanyifeng.com/?search=symbol&amp;x=15&amp;y=10#docs/symbol 4. 解构赋值数组解构赋值 1234567let a, b, c[a, b] = [1, 2]console.log(a, b) // 1 2// ...通常用于不知道剩余值数量的情况，或者是图简便的情况[a, b, ...c] = [1, 2, 3, 4, 5]console.log(c) // [3 4 5] 对象的解构赋值 12345678910111213141516171819202122// 情况 1let a, b(&#123;a, b&#125; = &#123;a:1, b:2&#125;)console.log(a, b) // 1 2// 情况 2let o = &#123;p: 1, q: true&#125;let &#123;p, q&#125; = oconsole.log(p, q) // 1 truelet &#123;a, b&#125; = oconsole.log(a ,b) // undefined undefined// 情况 3let metaO = &#123; name: 'bmwz110', inf: [&#123; name: 25 gender: 'male' &#125;]&#125;let &#123;name: outerName, inf:[&#123;name: innerName&#125;]&#125; = metaOconsole.log(outerName, innerName) // bmwz110 25 默认值的使用 12345678910let a, b, c[a, b, c] = [1, 2]console.log(a, b, c) // 1 2 undefined// 此时给c设置一个默认值，可以在等号右侧没有赋值的情况下使用默认值代替[a, b, c=3] = [1, 2]console.log(a, b, c) // 1 2 3[a, b, c=3] = [1, 2, 4]console.log(a, b, c) // 1 2 4 解构赋值还可被用于变量交换： 1234let a = 1let b = 2[a, b] = [b, a]console.log(a, b) // 2 1 函数返回值也能被用来解构赋值： 123456function f() &#123; return [1, 2, 3, 4, 5]&#125;let a, b, c[a,,,b] = f()console.log(a, b) // 1 4]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS事件委托]]></title>
    <url>%2F2019%2F01%2F02%2F20190102%2F</url>
    <content type="text"><![CDATA[事件委托(又名事件代理)，就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 网上有关于事件委托的一个“取快递”例子，生动形象，这里我把它作一点修改和拓展，来说明事件委托的机制。 某公司有三位员工，他们的快递收件地址为公司，每当有快递送达时，快递员拨打其电话进行通知，他们接到电话后去取件。 员工ID 员工名称 联系方式 A 甲 111111 B 乙 222222 C 丙 333333 对应到页面，就是每个员工是一个标记： 12345&lt;ul id="前台工作人员"&gt; &lt;li id="A"&gt;员工甲&lt;/li&gt; &lt;li id="B"&gt;员工乙&lt;/li&gt; &lt;li id="C"&gt;员工丙&lt;/li&gt;&lt;/ul&gt; 每位员工接电话取快递的行为就是一个个事件，这里我们假设收取快递行为对应着onclick事件： 123456789A.onclik = function() &#123; 收取快递；&#125;;B.onclick = function() &#123; 收取快递；&#125;;C.onclick = function() &#123; 收取快递；&#125;; 以上的实现，通常为通过循环遍历每一个员工，为其增加事件： 12345678/*程序1*/var aUl = document.getElemengtByID("前台工作人员");var aLi = aUl.getElemengtsByTagName("li");for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].onclick = function() &#123; 收取快递; &#125;&#125; 可以看到，为每个员工都设置一个事件，会产生冗余代码，占用内存，同时会进行多次DOM操作(与DOM节点进行交互)，影响页面运行性能。 “减少DOM操作是性能优化的主要思想之一” 于是，我们理所当然地想到：为什么不能让前台工作人员帮我们签收快递呢？ 1234567891011&lt;ul id="前台工作人员"&gt; &lt;li id="A"&gt;员工甲&lt;/li&gt; &lt;li id="B"&gt;员工乙&lt;/li&gt; &lt;li id="C"&gt;员工丙&lt;/li&gt;&lt;/ul&gt;/*程序2*/var tel = document.getElementById("前台工作人员");tel.onclick = function() &#123; 收取快递;&#125; 假设此时快递员打电话通知员工甲取件(onclick)，但员工甲的DOM节点&lt;li&gt;并无对应事件(onclick)，所以这个事件会“冒泡”到&lt;li&gt;的父元素&lt;ul&gt;，发现&lt;ul&gt;上有onclick处理事件，于是触发该事件，由前台工作人员收取快递。 可以看到，这样一来，不仅缩减代码量，同时与DOM节点的交互次数也得到了缩减。 还有一个优点：当增加新的DOM节点时，自动携带父元素的事件效果。也就是说，当有一个新员工丁来公司后，前台工作人员会直接帮他收取快递，而无需专门为他设置事件。 例如，当新员工丁来到公司后： 123...&lt;input type="button" id="btn" value="添加新员工"&gt;... 123456789.../*程序3*/var aBtn = document.getElementById("btn");aBtn.onclick = function() &#123; var aLi = document.createElement("li"); oLi.innerHTML = "员工丁"; aUl.appendChild(aLi);&#125;... 在不使用事件委托的程序中，新增的员工丁是没有事件的，我们需要用一个函数包含住程序1： 12345678910/*程序4*/function pro1() &#123; var aUl = document.getElemengtByID("前台工作人员"); var aLi = aUl.getElemengtsByTagName("li"); for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].onclick = function() &#123; 收取快递; &#125; &#125;&#125; 然后在新增新员工丁的程序的末尾执行这个函数： 123456/*程序5*/var aBtn = document.getElementById("btn");aBtn.onclick = function() &#123; ... pro1();&#125; 这样做的缺点是显而易见的：DOM节点交互次数成倍增加。若我们采用事件委托机制来实现，就不会存在这个问题，子元素节点的onclick事件会直接在父元素节点得到执行。 到这里，我们会想到：对于同一种事件来说，使用事件委托将其放置在父元素节点上固然很方便。但如果对于不同的子元素节点要执行不同的事件呢，还能使用事件委托吗？ 答案是肯定的。 例如上述三位公司员工，总是使用固定品牌的快递： 员工甲因为便宜，喜欢使用申通快递，申通只送到园区大门; 员工乙是京东会员，总是购买京东自营商品，京东快递送到楼下; 员工丙是顺丰VIP，顺丰快递会送到送到所在楼层大厅。 他们三位在接到电话后，前台工作人员需要去不同的地方取件，对于不使用事件委托的程序，需要对每个人设置独特的处理事件： 12345678910111213var A = document.getElementById("A");var B = document.getElementById("B");var C = document.getElementById("C");A.onclick = function() &#123; 去园区大门取快递；&#125;B.onclick = function() &#123; 去楼下取快递；&#125;C.onclick = function() &#123; 去本层大厅取快递；&#125; 至少需要三次DOM操作，而且为每一个对应节点都设置了事件函数。 而若采用事件委托： 123456789101112131415161718var aUl = document.getElemengtByID("前台工作人员");aUl.onclick = function (ev) &#123; var target = ev || window.event; /*兼容浏览器*/ var target = ev.target || ev.srcElement; /*兼容浏览器*/ if (target.nodeName.toLocaleLowerCase() == "li") &#123; switch(target.id) &#123; case "A" : 去园区大门取快递; break; case "B" : 去楼下取快递; break; case "C" : 去本层大厅取快递; break; &#125; &#125;&#125; 这样一来，DOM操作就只有一次，其他的操作都在JS内进行，可以有效提升网页性能。 以上便是JS事件委托的基本思想。简而言之，就是利用事件冒泡这一特点，来对事件进行管理，减少冗余代码，减少不必要的创建，减少交互操作以节约内存和提高性能。 事件冒泡事件冒泡是当触发某个DOM元素节点时，若该节点没有对应事件，则检查其父元素是否有对应事件，若有，则执行，若没有，继续向上检查。 关于事件流的具体分析，将在以后实践中总结。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS布局-三栏布局实现]]></title>
    <url>%2F2018%2F11%2F18%2F20181118%2F</url>
    <content type="text"><![CDATA[三栏是CSS布局中常见的一种布局模式，顾名思义，就是将网页内容以三列的形式呈现。通常，三栏布局中的左栏和右栏是固定宽度的，中栏随着窗口宽度的变化而变化。本文探讨栏三栏的基本实现思路和经典方法，对其中涉及到的知识点进行梳理。 目的：实现一个左栏和右栏宽300px，中间栏宽度自适应的三栏布局 基本实现思路首先，常规思路，我们写出3个div的HTML和CSS，分别是leftColumn(左栏)、middleColumn(中栏)和rightColumn(右栏)。 HTML：12345&lt;body&gt; &lt;div id="leftDiv"&gt;左栏&lt;/div&gt; &lt;div id="middleDiv"&gt;中栏&lt;/div&gt; &lt;div id="rightDiv"&gt;右栏&lt;/div&gt;&lt;/body&gt; CSS：1234567891011121314#leftDiv &#123; height: 300px; /*高度设为300像素，下同*/ background-color: rgb(60,139,176); /*设置背景颜色*/&#125;#middleDiv &#123; height: 300px; background-color: rgb(225,236,214);&#125;#rightDiv &#123; height: 300px; background-color: rgb(122,122,122);&#125; 此时，得到的网页如下图所示： 这是因为div的特性：默认宽度最大化(页面的100%)，默认高度最小化(根据内容自适应)。 上面的CSS中，只指定栏高度height:300px，未指定宽度，所以每个div都以宽度width:100%填满所在行。 注意：此时若尝试指定每个div的宽度，例如给每个div的CSS添加语句: 1width: 100px; 得到的页面如下图左图，而非右图。 这是因为div属于块级(block)元素，默认情况下，块级元素总是会另起一行。 为了使块级元素能位于同一行，最简单的方法是使用float属性。我们对每个div的CSS新增语句： 1234#leftDiv,#middleDiv,#rightDiv &#123; float: left; /*向左浮动*/ height: 300px; &#125; 使其向左浮动,得到的效果如下图所示： 可以看到，对CSS设置float:left属性后，三栏位于了同一行，宽度为其内容的适应宽度。此时，我们将左栏和右栏宽度设置为300px： 1234567#leftDiv,#rightDiv &#123; width: 300px; /*设置宽度为300像素*/ ... &#125;#middleDiv &#123; ...&#125; 得到的效果如下图所示： 此时，中栏的宽度仍为其内容的适应宽度，我们为middleDiv添加如下语句： 1width: calc(100% - 600px); /*设置middleDiv宽度*/ calc()的作用为动态计算长度值，允许各种单位混合运算，运算符前后需有空格。 于是我们得到了最终效果。左栏和右栏各300px宽，中栏根据浏览器窗口大小进行动态调整。但需要注意的是，当浏览器窗口宽度小于600px时，中栏的宽度将小于0。为此，我们可以为浏览其设置最小调整宽度，避免页面混乱：123body &#123; min-width: 700px;&#125; 至此，一个三栏布局就完成了。这种实现思路比较符合人的思维定势，但也存在一定的缺陷：浏览器加载和渲染页面遵循从上到下的原则，这种方法中，HTML的middleDiv(中栏)位列于leftDiv(左栏)之后，所以会在leftDiv之后加载，而middleDiv往往是页面的核心，需要优先加载展示给用户。 于是，我们思考将middleDiv放在HTML中的首位：12345&lt;body&gt; &lt;div id="middleDiv"&gt;中栏&lt;/div&gt; &lt;div id="leftDiv"&gt;左栏&lt;/div&gt; &lt;div id="rightDiv"&gt;右栏&lt;/div&gt;&lt;/body&gt; CSS中，我们仍然设置middleDiv(中栏)的宽度为100% - 600px：1234#middleDiv &#123; width: calc(100% - 600px); ...&#125; 此时的界面如图所示： 可以看到，由于我们在HTML中将middleDiv(中栏)放在栏首位，所以浏览器窗口中，中栏显示在最前面。这时，我们需要为leftDiv(左栏)腾出空间，可以使用margin-left或padding-left。 margin和padding分别为盒模型的外边距和内边距，此处使用两者皆可，此处唯一的区别是padding会被底色填充而margin不会。因为background-color的填充区域为content+padding+border。 还有一点需要注意的是，padding值不能为负，对于需要取负值时，仅可使用margin。 为middleDiv(中栏)添加以下语句： 1margin-left: 300px; 此时效果如下图所示： 可以看到，由于增加了300px的外边距，第一行的横向空间被middleDiv(中栏)和leftDiv(左栏)填满，rightDiv(右栏)被迫位列第二行。 此时，我们使用relative属性对左栏和右栏进行处理：123456789101112#leftDiv &#123; position: relative; /*相对定位*/ left: calc(300px - 100%); /*左移*/ ...&#125;#rightDiv &#123; position: relative; top: -300px; /*上移*/ left: calc(100% - 300px); /*右移*/ ...&#125; 至此，我们在保证middleDiv(中栏)先行加载渲染的条件下，完成了三栏布局。基本思路为通过相对定位实现。 经典方法CSS三栏布局的方法有很多种，其中最经典的方法莫过于圣杯布局和双飞翼布局。圣杯布局因形似圣杯而得名，即中栏为杯身，左右两栏为杯耳。双飞翼布局则是圣杯布局的一种改进，去掉了relative属性，并为主体部分增加了内容嵌套。 圣杯布局(In Search of the Holy Grail)圣杯布局和双飞翼布局都需要在HTML中为div增加一层“容器(container)”。这个容器的目的主要是为了利用padding对中栏进行调整。 1234567&lt;body&gt; &lt;div id="container"&gt; &lt;div id="middleDiv"&gt;中栏&lt;/div&gt; &lt;div id="leftDiv"&gt;左栏&lt;/div&gt; &lt;div id="rightDiv"&gt;右栏&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 首先，仍然设置float:left属性使div浮动，使其位于一行。1234#leftDiv,#middleDiv,#rightDiv &#123; float: left; ...&#125; 然后，将middleDiv(中栏)的宽度width设为100%：1234#middleDiv &#123; width: 100%; ...&#125; 得到如下图所示的布局： 此时，需要将leftDiv置于第一行左侧: 1margin-left: -100%; /* 左侧边界前移100% */ 这样处理的结果是leftDiv(左栏)被置于第一行最左端，但会覆盖middleDiv(中栏)的部分内容。我们需要将中栏的内容从被覆盖的地方拉出来。一个简便的方法是对父容器container使用margin：123#container &#123; margin: 0 300px 0 300px;&#125; 此处使用padding:0 300px 0 300px; 效果相同。 此时，leftDiv(左栏)也会受父容器的影响向右移动300px，仍然覆盖着middleDiv(中栏)的一部分，所以我们使用相对定位让其向左移动：12345#leftDiv &#123; position: relative; left: -300px; ...&#125; 此时的布局如下图所示： 对rightDiv(右栏)作类似处理：123456#rightDiv &#123; margin-left: -300px; /*左侧边界前移300px*/ position: relative; right: -300px; /*右侧边界右移300px*/ ... &#125; 不要忘记为body设定最小宽度：123body &#123; min-width: 800px;&#125; 至此完成。 可以看到，圣杯布局的实现思想是给div套上一个父容器，通过调整父容器的padding和div左右栏的相对定位来实现三栏布局。 双飞翼布局双飞翼布局，源于淘宝UED，是圣杯布局的一种改进，或者说是另一种三栏实现思路。其创新点在于额外为middleDiv(中栏)增加一个子div存放其内容。123456789&lt;body&gt; &lt;div id="container"&gt; &lt;div id="middleDiv"&gt; &lt;div id="content"&gt;中栏&lt;/div&gt; &lt;/div&gt; &lt;div id="leftDiv"&gt;左栏&lt;/div&gt; &lt;div id="rightDiv"&gt;右栏&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 仍然使用float属性来对div进行浮动：1234#leftDiv,#middleDiv,#rightDiv &#123; float: left; ...&#125; 与圣杯类似，设置middleDiv(中栏)宽度为100%，且将leftDiv(左栏)拉到最左侧，将rightDiv(右栏)作类似处理：123456789101112#middleDiv &#123; width: 100%; ...&#125;#leftDiv &#123; margin-left: -100%;&#125;#rightDiv &#123; margin-left: -300px;&#125; 到这一步为止，双飞翼布局方法和圣杯CSS方法并不不同。 此时，由于双飞翼布局方法为middleDiv(中栏)单独添加了一个div存放其内容，所以对于中栏的处理，可以使用该div的margin属性：123#content &#123; margin: 0 300px 0 300px;&#125; 此处使用padding:0 300px 0 300px; 效果相同。 同样，不要忘记为body设定最小宽度：123body &#123; min-width: 800px;&#125; 至此完成。 可见，圣杯布局方法与双飞翼布局方法的区别在于圣杯布局采用相对位置属性(position:relative)来调整左栏和右栏位置，并使用margin/padding属性调整中栏。而双飞翼布局方法无需相对位置属性，而是采用为中栏内容创建div的方式，通过margin/padding来实现布局。 总结本文探讨了三栏布局的CSS基本实现方法，首先以基本思路对三栏布局进行实现，发现不足，进行调整。文章第二部分阐述了流行的圣杯布局方法和双飞翼布局方法的细节和异同。除本文所述布局方法外，还存在绝对定位法、table布局法、网格布局法等多种方法，各有利弊，可根据需求使用和改造。关于这些方法的讨论将在以后实际应用时进行总结。]]></content>
      <categories>
        <category>HTML/CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[域名更新]]></title>
    <url>%2F2018%2F11%2F14%2F20181114%2F</url>
    <content type="text"><![CDATA[博客网址更新 网站注册新域名：https://www.bmwz110.top 读者仍可通过：https://bmwz110.github.io 访问]]></content>
      <categories>
        <category>通知</category>
      </categories>
  </entry>
</search>
