<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅拷贝和深拷贝]]></title>
    <url>%2F2019%2F04%2F08%2F20190408%2F</url>
    <content type="text"><![CDATA[什么是深拷贝和浅拷贝呢？ 名称 定义 浅拷贝 对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝 深拷贝 对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容 也就是说，对于a，让b对a进行拷贝，之后当a发生变化，若b也跟着发生变化，就是浅拷贝；若a发生变化，b不变化，那就是深拷贝。 基本数据类型 引用数据类型 Number、String、Boolean、Null、Undefined等 Object、Array、Function等 基本数据类型是按值访问的，对其的拷贝会直接复制其值保存在新变量中。例如Number类型： 12345var a = 1;b = a;console.log(b); // 1a = 2;console.log(b); //1 （a的变化不会影响b的值） 而“引用数据类型”是按引用访问的，对其直接进行拷贝只会操作引用地址，而不是值本身。例如Array类型： 1234567var a = [1, 2, 3];b = a;console.log(a); // [1, 2, 3]console.log(b); // [1, 2, 3]a[0] = 2;console.log(a); // [2, 2, 3]console.log(b); // [2, 2, 3] （对数组a的改动也影响了数组b） 其原理如下图所示： 那么，如何对引用数据类型实现深拷贝呢？ 显而易见的思路是：既然是因为引用地址造成了无法深拷贝，那就抛开引用地址，直接对值进行遍历，将其拷贝给新的变量。 方法1: 手工遍历法12345678910111213141516let a = [1, [2, 3], 4];const copy = (obj) =&gt; &#123; let newObj = obj.constructor === Array ? [] : &#123;&#125; if(typeof obj !== &apos;object&apos;) &#123; return; &#125; for(let i in obj) &#123; newObj[i] = typeof obj[i] === &apos;object&apos; ? copy(obj[i]) : obj[i] &#125; return newObj&#125;let b = copy(a); a[1][0] = 3;console.log(a); // [1, [3, 3], 4]console.log(b); // [1, [2, 3], 4] 方法2: JSON方法123456789101112let a = [1, [2, 3], 4];const copy = (obj) =&gt; &#123; let _obj = JSON.stringify(obj) let newObj = JSON.parse(_obj) return newObj&#125;let b = copy(a); a[1][0] = 3;console.log(a); // [1, [3, 3], 4]console.log(b); // [1, [2, 3], 4] 方法3: JQuery-extend方法1234567let a = [1, [2, 3], 4];b = $.extend(true,[],a);a[1][0] = 3;console.log(a); // [1, [3, 3], 4]console.log(b); // [1, [2, 3], 4]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6知识点整理]]></title>
    <url>%2F2019%2F03%2F17%2F20190317%2F</url>
    <content type="text"><![CDATA[1. let关键字let关键字是ES6添加的新关键字，作用是声明变量，主要为了弥补var关键字声明变量的缺点。 var关键字声明变量的缺点： 作用域互相干扰 var arr = []; for(var i=0; i&lt;10; i++) { arr[i] = function() { alert(i) } } arr[5](); //结果10 块级作用域：一对花括号{}就是一个块，for循环的每一次循环都会创建一个块。 可以看出，var声明的变量i的值会干扰到各个块级作用域里的i，最后一个i的值为10，于是其他块级作用域中的i也都变成了10。 将var替换为let来声明变量就可以规避这种干扰： ... for(let i=0; i&lt;10; i++) ... arr[5](); //结果5 “变量提升”现象 观察下面这段代码： var a = 1; x = function() { alert(a); var a = 2; }; x(); //undefined console.log(a); //1 预期的输出结果应该是：先弹出alert窗口显示1，然后a的值在函数体内的局部作用域被赋为2。但现实情况是alert窗口显示undefined。 这是因为上述函数内声明并定义变量a的语句”var a = 2”实际被拆分为两部分”var a”和”a = 2”，且第一部分”var a”被提前到函数体最前端（如下）： var a = 1; x = function() { var a; alert(a); a = 2; }; x(); 对于alert(a)来说，局部变量a并未定义，从而导致alert(a)出现undefined，这就是变量提升现象。 同样，使用let可以消除这种影响： var a = 1; x = function() { alert(a); let a = 2; }; x(); //a is not defined console.log(a); //1 这是因为，块级作用域内let声明变量a是封闭自给的，外界的变量a无法作用于内部。此时，要求“先声明后使用”，需要将”let a = 2”写在”alert(a)”之前。 var a = 1; x = function() { let a = 2; alert(a); }; x(); //&quot;弹窗提示&quot;：2 console.log(a); //1 需要注意的是：同一个块级作用域内，使用let声明变量时，同一个变量只允许声明1次。以下做法是错误的： { var a = 1; let a = 2; } //a has already been declared { let a = 1; var a = 2; } //a has already been declared { let a = 1; let a = 2; } //a has already been declared 还有需要注意的是：函数内不能使用let重新声明函数的参数。以下做法是错误的： var a = 1; x = function(a) { let a = 2; alert(a); } x(); //a has already been declared 这是因为函数通过参数引入了”var a = 1”，相当于在函数体内存在了这一声明，再使用let对a进行声明便犯了重复声明的错误， 总结： let关键字：1.只在块级作用域起作用；2.不可重复声明同一变量；3.不可声明函数参数； 2. const关键字const是constant(常量)的缩写，专用于声明常量。 ++let关键字有的特性，const全都有，并且const还多了2个特性++： 特性1: 不可修改 const a = 1; a = 2; //error 特性2: 声明后必须赋值 const a; //error 对于特性1，有一点需要注意，当常量是值时，传值赋值的值是不可修改的。即当常量是一个对象时，使用的是传址赋值，不可修改的是“址”，而不是“值”。 例如： const a = {&quot;number&quot;:1}; a.number = 2; a.name = &quot;math&quot;; console.log(a); //{number:2, name:math} 即对于传址赋值的情况，在值的层面是可以修改的。 3. SymbolSymbol是ES6中新增的数据类型，与之前的Number, String, Boolean, Null, Undefined, Object一起，成为7大数据类型。 作用：主要是为了防止属性名冲突造成的覆盖。例如当你调用他人的对象时，添加了一个名为a的方法，可能会覆盖掉他人对象中原本的a。 12345678910111213141516171819202122&lt;script&gt; let obj = &#123; a: &quot;hello&quot;, b: &quot;world&quot; &#125; let a = Symbol(); let b = Symbol(&quot;标记&quot;); //Symbol中的字符串是为了区分不同的Symbol obj[a] = &quot;one&quot;; obj[b] = &quot;two&quot;; console.log(obj); // a: &quot;hello&quot; // b: &quot;world&quot; // Symbol(): &quot;one&quot; // Symbol(标记): &quot;two&quot; console.log(obj.a); //hello console.log(obj[a]); //one for(let item in obj) &#123; console.log(item) &#125; // a b&lt;/script&gt; 其他关于Symbol的具体特性，可参见http://es6.ruanyifeng.com/?search=symbol&amp;x=15&amp;y=10#docs/symbol]]></content>
      <categories>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS事件委托]]></title>
    <url>%2F2018%2F12%2F02%2F20181202%2F</url>
    <content type="text"><![CDATA[事件委托(又名事件代理)，就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 网上有关于事件委托的一个“取快递”例子，生动形象，这里我把它作一点修改和拓展，来说明事件委托的机制。 某公司有三位员工，他们的快递收件地址为公司，每当有快递送达时，快递员拨打其电话进行通知，他们接到电话后去取件。 员工ID 员工名称 联系方式 A 甲 111111 B 乙 222222 C 丙 333333 对应到页面，就是每个员工是一个标记： &lt;ul id=&quot;前台工作人员&quot;&gt; &lt;li id=&quot;A&quot;&gt;员工甲&lt;/li&gt; &lt;li id=&quot;B&quot;&gt;员工乙&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;员工丙&lt;/li&gt; &lt;/ul&gt; 每位员工接电话取快递的行为就是一个个事件，这里我们假设收取快递行为对应着onclick事件： A.onclik = function() { 收取快递； }; B.onclick = function() { 收取快递； }; C.onclick = function() { 收取快递； }; 以上的实现，通常为通过循环遍历每一个员工，为其增加事件： /*程序1*/ var aUl = document.getElemengtByID(&quot;前台工作人员&quot;); var aLi = aUl.getElemengtsByTagName(&quot;li&quot;); for (var i = 0; i &lt; aLi.length; i++) { aLi[i].onclick = function() { 收取快递; } } 可以看到，为每个员工都设置一个事件，会产生冗余代码，占用内存，同时会进行多次DOM操作(与DOM节点进行交互)，影响页面运行性能。 “减少DOM操作是性能优化的主要思想之一” 于是，我们理所当然地想到：为什么不能让前台工作人员帮我们签收快递呢？ &lt;ul id=&quot;前台工作人员&quot;&gt; &lt;li id=&quot;A&quot;&gt;员工甲&lt;/li&gt; &lt;li id=&quot;B&quot;&gt;员工乙&lt;/li&gt; &lt;li id=&quot;C&quot;&gt;员工丙&lt;/li&gt; &lt;/ul&gt; /*程序2*/ var tel = document.getElementById(&quot;前台工作人员&quot;); tel.onclick = function() { 收取快递; } 假设此时快递员打电话通知员工甲取件(onclick)，但员工甲的DOM节点&lt;li&gt;并无对应事件(onclick)，所以这个事件会“冒泡”到&lt;li&gt;的父元素&lt;ul&gt;，发现&lt;ul&gt;上有onclick处理事件，于是触发该事件，由前台工作人员收取快递。 可以看到，这样一来，不仅缩减代码量，同时与DOM节点的交互次数也得到了缩减。 还有一个优点：当增加新的DOM节点时，自动携带父元素的事件效果。也就是说，当有一个新员工丁来公司后，前台工作人员会直接帮他收取快递，而无需专门为他设置事件。 例如，当新员工丁来到公司后： ... &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;添加新员工&quot;&gt; ... ... /*程序3*/ var aBtn = document.getElementById(&quot;btn&quot;); aBtn.onclick = function() { var aLi = document.createElement(&quot;li&quot;); oLi.innerHTML = &quot;员工丁&quot;; aUl.appendChild(aLi); } ... 在不使用事件委托的程序中，新增的员工丁是没有事件的，我们需要用一个函数包含住程序1： /*程序4*/ function pro1() { var aUl = document.getElemengtByID(&quot;前台工作人员&quot;); var aLi = aUl.getElemengtsByTagName(&quot;li&quot;); for (var i = 0; i &lt; aLi.length; i++) { aLi[i].onclick = function() { 收取快递; } } } 然后在新增新员工丁的程序的末尾执行这个函数： /*程序5*/ var aBtn = document.getElementById(&quot;btn&quot;); aBtn.onclick = function() { ... pro1(); } 这样做的缺点是显而易见的：DOM节点交互次数成倍增加。若我们采用事件委托机制来实现，就不会存在这个问题，子元素节点的onclick事件会直接在父元素节点得到执行。 到这里，我们会想到：对于同一种事件来说，使用事件委托将其放置在父元素节点上固然很方便。但如果对于不同的子元素节点要执行不同的事件呢，还能使用事件委托吗？ 答案是肯定的。 例如上述三位公司员工，总是使用固定品牌的快递： 员工甲因为便宜，喜欢使用申通快递，申通只送到园区大门; 员工乙是京东会员，总是购买京东自营商品，京东快递送到楼下; 员工丙是顺丰VIP，顺丰快递会送到送到所在楼层大厅。 他们三位在接到电话后，前台工作人员需要去不同的地方取件，对于不使用事件委托的程序，需要对每个人设置独特的处理事件： var A = document.getElementById(&quot;A&quot;); var B = document.getElementById(&quot;B&quot;); var C = document.getElementById(&quot;C&quot;); A.onclick = function() { 去园区大门取快递； } B.onclick = function() { 去楼下取快递； } C.onclick = function() { 去本层大厅取快递； } 至少需要三次DOM操作，而且为每一个对应节点都设置了事件函数。 而若采用事件委托： var aUl = document.getElemengtByID(&quot;前台工作人员&quot;); aUl.onclick = function (ev) { var target = ev || window.event; /*兼容浏览器*/ var target = ev.target || ev.srcElement; /*兼容浏览器*/ if (target.nodeName.toLocaleLowerCase() == &quot;li&quot;) { switch(target.id) { case &quot;A&quot; : 去园区大门取快递; break; case &quot;B&quot; : 去楼下取快递; break; case &quot;C&quot; : 去本层大厅取快递; break; } } } 这样一来，DOM操作就只有一次，其他的操作都在JS内进行，可以有效提升网页性能。 以上便是JS事件委托的基本思想。简而言之，就是利用事件冒泡这一特点，来对事件进行管理，减少冗余代码，减少不必要的创建，减少交互操作以节约内存和提高性能。 事件冒泡事件冒泡是当触发某个DOM元素节点时，若该节点没有对应事件，则检查其父元素是否有对应事件，若有，则执行，若没有，继续向上检查。 关于事件流的具体分析，将在以后实践中总结。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS布局-三栏布局实现]]></title>
    <url>%2F2018%2F11%2F18%2F20181118%2F</url>
    <content type="text"><![CDATA[三栏是CSS布局中常见的一种布局模式，顾名思义，就是将网页内容以三列的形式呈现。通常，三栏布局中的左栏和右栏是固定宽度的，中栏随着窗口宽度的变化而变化。本文探讨栏三栏的基本实现思路和经典方法，对其中涉及到的知识点进行梳理。 目的：实现一个左栏和右栏宽300px，中间栏宽度自适应的三栏布局 基本实现思路首先，常规思路，我们写出3个div的HTML和CSS，分别是leftColumn(左栏)、middleColumn(中栏)和rightColumn(右栏)。 HTML： &lt;body&gt; &lt;div id=&quot;leftDiv&quot;&gt;左栏&lt;/div&gt; &lt;div id=&quot;middleDiv&quot;&gt;中栏&lt;/div&gt; &lt;div id=&quot;rightDiv&quot;&gt;右栏&lt;/div&gt; &lt;/body&gt; CSS： #leftDiv { height: 300px; /*高度设为300像素，下同*/ background-color: rgb(60,139,176); /*设置背景颜色*/ } #middleDiv { height: 300px; background-color: rgb(225,236,214); } #rightDiv { height: 300px; background-color: rgb(122,122,122); } 此时，得到的网页如下图所示： 这是因为div的特性：默认宽度最大化(页面的100%)，默认高度最小化(根据内容自适应)。 上面的CSS中，只指定栏高度height:300px，未指定宽度，所以每个div都以宽度width:100%填满所在行。 注意：此时若尝试指定每个div的宽度，例如给每个div的CSS添加语句: width: 100px; 得到的页面如下图左图，而非右图。 这是因为div属于块级(block)元素，默认情况下，块级元素总是会另起一行。 为了使块级元素能位于同一行，最简单的方法是使用float属性。我们对每个div的CSS新增语句： #leftDiv,#middleDiv,#rightDiv { float: left; /*向左浮动*/ height: 300px; } 使其向左浮动,得到的效果如下图所示： 可以看到，对CSS设置float:left属性后，三栏位于了同一行，宽度为其内容的适应宽度。此时，我们将左栏和右栏宽度设置为300px： #leftDiv,#rightDiv { width: 300px; /*设置宽度为300像素*/ ... } #middleDiv { ... } 得到的效果如下图所示： 此时，中栏的宽度仍为其内容的适应宽度，我们为middleDiv添加如下语句： width: calc(100% - 600px); /*设置middleDiv宽度*/ calc()的作用为动态计算长度值，允许各种单位混合运算，运算符前后需有空格。 于是我们得到了最终效果。左栏和右栏各300px宽，中栏根据浏览器窗口大小进行动态调整。但需要注意的是，当浏览器窗口宽度小于600px时，中栏的宽度将小于0。为此，我们可以为浏览其设置最小调整宽度，避免页面混乱： body { min-width: 700px; } 至此，一个三栏布局就完成了。这种实现思路比较符合人的思维定势，但也存在一定的缺陷：浏览器加载和渲染页面遵循从上到下的原则，这种方法中，HTML的middleDiv(中栏)位列于leftDiv(左栏)之后，所以会在leftDiv之后加载，而middleDiv往往是页面的核心，需要优先加载展示给用户。 于是，我们思考将middleDiv放在HTML中的首位： &lt;body&gt; &lt;div id=&quot;middleDiv&quot;&gt;中栏&lt;/div&gt; &lt;div id=&quot;leftDiv&quot;&gt;左栏&lt;/div&gt; &lt;div id=&quot;rightDiv&quot;&gt;右栏&lt;/div&gt; &lt;/body&gt; CSS中，我们仍然设置middleDiv(中栏)的宽度为100% - 600px： #middleDiv { width: calc(100% - 600px); ... } 此时的界面如图所示： 可以看到，由于我们在HTML中将middleDiv(中栏)放在栏首位，所以浏览器窗口中，中栏显示在最前面。这时，我们需要为leftDiv(左栏)腾出空间，可以使用margin-left或padding-left。 margin和padding分别为盒模型的外边距和内边距，此处使用两者皆可，此处唯一的区别是padding会被底色填充而margin不会。因为background-color的填充区域为content+padding+border。 还有一点需要注意的是，padding值不能为负，对于需要取负值时，仅可使用margin。 为middleDiv(中栏)添加以下语句： margin-left: 300px; 此时效果如下图所示： 可以看到，由于增加了300px的外边距，第一行的横向空间被middleDiv(中栏)和leftDiv(左栏)填满，rightDiv(右栏)被迫位列第二行。 此时，我们使用relative属性对左栏和右栏进行处理： #leftDiv { position: relative; /*相对定位*/ left: calc(300px - 100%); /*左移*/ ... } #rightDiv { position: relative; top: -300px; /*上移*/ left: calc(100% - 300px); /*右移*/ ... } 至此，我们在保证middleDiv(中栏)先行加载渲染的条件下，完成了三栏布局。基本思路为通过相对定位实现。 经典方法CSS三栏布局的方法有很多种，其中最经典的方法莫过于圣杯布局和双飞翼布局。圣杯布局因形似圣杯而得名，即中栏为杯身，左右两栏为杯耳。双飞翼布局则是圣杯布局的一种改进，去掉了relative属性，并为主体部分增加了内容嵌套。 圣杯布局(In Search of the Holy Grail)圣杯布局和双飞翼布局都需要在HTML中为div增加一层“容器(container)”。这个容器的目的主要是为了利用padding对中栏进行调整。 &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;middleDiv&quot;&gt;中栏&lt;/div&gt; &lt;div id=&quot;leftDiv&quot;&gt;左栏&lt;/div&gt; &lt;div id=&quot;rightDiv&quot;&gt;右栏&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 首先，仍然设置float:left属性使div浮动，使其位于一行。 #leftDiv,#middleDiv,#rightDiv { float: left; ... } 然后，将middleDiv(中栏)的宽度width设为100%： #middleDiv { width: 100%; ... } 得到如下图所示的布局： 此时，需要将leftDiv置于第一行左侧: margin-left: -100%; /* 左侧边界前移100% */ 这样处理的结果是leftDiv(左栏)被置于第一行最左端，但会覆盖middleDiv(中栏)的部分内容。我们需要将中栏的内容从被覆盖的地方拉出来。一个简便的方法是对父容器container使用margin： #container { margin: 0 300px 0 300px; } 此处使用padding:0 300px 0 300px; 效果相同。 此时，leftDiv(左栏)也会受父容器的影响向右移动300px，仍然覆盖着middleDiv(中栏)的一部分，所以我们使用相对定位让其向左移动： #leftDiv { position: relative; left: -300px; ... } 此时的布局如下图所示： 对rightDiv(右栏)作类似处理： #rightDiv { margin-left: -300px; /*左侧边界前移300px*/ position: relative; right: -300px; /*右侧边界右移300px*/ ... } 不要忘记为body设定最小宽度： body { min-width: 800px; } 至此完成。 可以看到，圣杯布局的实现思想是给div套上一个父容器，通过调整父容器的padding和div左右栏的相对定位来实现三栏布局。 双飞翼布局双飞翼布局，源于淘宝UED，是圣杯布局的一种改进，或者说是另一种三栏实现思路。其创新点在于额外为middleDiv(中栏)增加一个子div存放其内容。 &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;middleDiv&quot;&gt; &lt;div id=&quot;content&quot;&gt;中栏&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;leftDiv&quot;&gt;左栏&lt;/div&gt; &lt;div id=&quot;rightDiv&quot;&gt;右栏&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 仍然使用float属性来对div进行浮动： #leftDiv,#middleDiv,#rightDiv { float: left; ... } 与圣杯类似，设置middleDiv(中栏)宽度为100%，且将leftDiv(左栏)拉到最左侧，将rightDiv(右栏)作类似处理： #middleDiv { width: 100%; ... } #leftDiv { margin-left: -100%; } #rightDiv { margin-left: -300px; } 到这一步为止，双飞翼布局方法和圣杯CSS方法并不不同。 此时，由于双飞翼布局方法为middleDiv(中栏)单独添加了一个div存放其内容，所以对于中栏的处理，可以使用该div的margin属性： #content { margin: 0 300px 0 300px; } 此处使用padding:0 300px 0 300px; 效果相同。 同样，不要忘记为body设定最小宽度： body { min-width: 800px; } 至此完成。 可见，圣杯布局方法与双飞翼布局方法的区别在于圣杯布局采用相对位置属性(position:relative)来调整左栏和右栏位置，并使用margin/padding属性调整中栏。而双飞翼布局方法无需相对位置属性，而是采用为中栏内容创建div的方式，通过margin/padding来实现布局。 总结本文探讨了三栏布局的CSS基本实现方法，首先以基本思路对三栏布局进行实现，发现不足，进行调整。文章第二部分阐述了流行的圣杯布局方法和双飞翼布局方法的细节和异同。除本文所述布局方法外，还存在绝对定位法、table布局法、网格布局法等多种方法，各有利弊，可根据需求使用和改造。关于这些方法的讨论将在以后实际应用时进行总结。]]></content>
      <categories>
        <category>HTML/CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[域名更新]]></title>
    <url>%2F2018%2F11%2F14%2F20181114%2F</url>
    <content type="text"><![CDATA[博客网址更新 网站注册新域名：https://www.bmwz110.top 读者仍可通过：https://bmwz110.github.io 访问]]></content>
      <categories>
        <category>通知</category>
      </categories>
  </entry>
</search>
